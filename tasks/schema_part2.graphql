

type Country @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID,
  name: String
}


type Region @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  countryId: ID!
  id: ID,
  name: String
}


type City @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  countryId: ID!
  regionId: ID!
  id: ID,
  name: String
}


type Bucket @model
@auth (
  rules: [
    { allow: public, provider: apiKey, operations: [read, update, delete, create] }
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
)
{
  id: ID!
  customerId:  ID! @index(name: "byCustomer", queryField: "bucketByCustomer")
  customer:  Customer! @belongsTo(fields: ["customerId"])
  products: [BucketItem]
}

type BucketItem{
  productId: ID!
  configurationId: String
  weight: String
  promotionId: String
  quantity: Int!
}

type Favorites @model
@auth (
  rules: [
    { allow: public, provider: apiKey, operations: [read, update, delete, create] }
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
)
{
  id: ID!
  customerId:  ID! @index(name: "byCustomer", queryField: "favouritesByCustomer")
  customer:  Customer! @belongsTo(fields: ["customerId"])
  products: [String]
}

enum CustomerStatus{
  vip
  bad
}

type EntityInfo{
   legalName: String
   fax: String
   INN: String 
   KPP: String
   legalAddress: String
   OKPO: String
   OKONH: String
   checkingAccount: String
   corrAccount: String
   BIK: String
}

type Address{
  index: String
  country: String 
  region: String
  city: String
  street: String
  structure: String  # Строение
  entrance: String   # Подъезд
  flat: String       # Квартира
  floor: Int         # этаж
  house: String      # дом 
  housing: String    # корпус
  metro: String 
  notes: String 
  text: String
  intercomCode: String
  isFlat: Boolean
  isOffice: Boolean
}

type Tags{
   name: String
   color: String
}

enum Sex{
    M   #Мужской
    W   #Женский
}

enum EmailMarketingUnsubscribedAt{
  S   #Подписан
  U  # Отписался
}


type OfferProduct{
  price: String,
  prod: String,
  externalCode: String

}

type AnalogProduct{
  price: String,
  prod: String,
  externalCode: String
}


enum FilterFields{
  tasksCounts
  sources
  keywords
  firstWebVisit
  firstOrder
  lastWebVisit
  lastOrder
  adContents
  email
  companyName
  marginSumm
  receiptFiscalDocumentAttribute
  receiptStatus
  campaigns
  mediums
  online
  customer
  customerType
  purchaseSumm
  totalSumm
  costSumm
  deliveryTime
  city
  deliveryDate
  deliveryExternalId
  index
  couriers
  metro
  trackNumber
  region
  deliveryNetCost
  deliveryStates
  deliveryCost
  deliveryTypes
  externalId
  managerGroups
  createdAt
  customerComment
  managerComment
  sites
  managers
  number
  flags
  statusUpdatedAt
  attachments
  orderMethods
  countries
  orderTypes
  product
  paidAt
  fullPaidAt
  receiptOperation
  paymentState
  prepaySum
  receiptOrderStatus
  paymentStatuses
  paymentTypes
  mgChannels
  shipmentDate
  shipmentStores
  shipped
}



type PriceType @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  active: Boolean
  isPromotionalPrice: Boolean
  basePrice: BasePrice
  ordering: Int
  description: String
  groups: [String]     # строка - characterCode группы
  filterExpression: String
  geo: RegionalRestrictions
}

enum BasePrice{
  N #no
  Y #yes
}

type RegionalRestrictions{
  location:  [LocationItem]
}



type Courier @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  lastName: String
  firstName: String!
  patronymic: String 
  email: String
  phone: String
  active: Boolean
  description: String
}


type Unit @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  sym: String!
  active: Boolean
  default: Boolean
}


type CostGroup @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  active: Boolean
  ordering: Int
  color: String
}


type CostItem @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  active: Boolean
  ordering: Int
  group: ID!
  type: TypeExpanse!
  appliesToOrders: Boolean
  appliesToUsers: Boolean,
  # source: Source
}

enum TypeExpanse{
  fixed     #постоянные
  variables #переменные
}

type Source{
  medium: String #ID   #chanel
  source: String #ID
  campaign: String #ID
  keyword: String #ID
  content: String #ID
}


type StatusGroup @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  active: Boolean
  ordering: Int!
  color: String
  default: Boolean
  type: Type
}
enum Type{
  default
  custom
}

type Status @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  code: String!
  active: Boolean
  ordering: Int!
  group: ID!
  groupInfo: StatusGroup @hasOne(fields: ["group"])
}

type GeneralSettings @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  company: String!
  systemLanguage: SystemLanguage!
  listAvailableCountries: [String]  
  defaultCurrency: String!
  timeZone: String! 
  statusMatrix: StatusMatrix!
  workingTime: [WorkTime]
  noWorkingDates: [String]
  ipRestriction: String
  twoFactorAuth: TwoFactorAuth!
  productsQuantity: ProductsQuantity!
  weightAccuracy: WeightAccuracy!
  printingForms: PrintingForms!
}


enum SystemLanguage{
  R     # русский
  E     # английский
  S     # испанский
}

enum StatusMatrix{
  none                                             # Не использовать
  order_types_only                       # Для типов заказов
  order_types_user_groups        # Для типов заказов и групп пользователей
}

type WorkTime{
  daysOfWeek: [Days]
  startTime: String
  endTime: String
  lunchStartTime: String
  lunchEndTime: String

}

# enum TwoFactorAuth{
#   N  # не использовать
# }

enum ProductsQuantity{
  W  # Целое
  F   # Дробное
}
enum WeightAccuracy{
  G # Граммы
  M # Миллиграммы
}

enum PrintingForms{
  D  # Скачивать
  O  # Открывать
}


type TransitionStatuses @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  orderTypeId: ID
  orderType: OrderType @hasOne(fields:["orderTypeId"])
  userGroupId: ID
  userGroup: UserGroup @hasOne(fields:["userGroupId"])
  matrix: String 
}


type Filter @model
@auth (
  rules: [
    { allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
){
  id: ID!
  name: String!
  filter: FilterItems!
}

type FilterItems{
  manager: String
  country: String
  email: String
  number: String
  fio: String
  statuses: [String]
}



type platformSettings @model
@auth (
  rules: [
    { allow: public, provider: apiKey, operations: [read] }
    {allow: private, provider: userPools, operations: [read, update, delete, create] }
  ]
)
{
  id: ID!
  distribution: Distribution
  emailNotification: Boolean
}

enum Distribution{
  do_not_assign  # не назначать
  assign_evenly  # назначить равномерно
}
